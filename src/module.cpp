////////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "module.h"
#include "parser.h"

// STD Includes
#include <fstream>
#include <iostream>
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
namespace medusa {
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//
// class CModule
//

// Constructors
CModule::CModule(std::string const& strModulePath)
{
	parser::CParser parser;
	m_pBuffer = parser.Parse(strModulePath);
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// class CModuleManager
//

// Interface Methodes
std::shared_ptr<CModule> CModuleManager::Load(std::string const& strModulePath)
{
	auto mapIterator = m_mapPathToModule.find(strModulePath);
	if (mapIterator == m_mapPathToModule.cend())
	{
		std::shared_ptr<CModule> pModule(new (std::nothrow) CModule(strModulePath));
		if (pModule == nullptr)
		{
			CInterrupt interrupt(CInterrupt::LoadModule, "Unable to create the module from the >> " + strModulePath);
			throw(interrupt);
		}

		m_mapPathToModule.emplace(strModulePath, pModule);

		return pModule;
	}

	if (mapIterator->second == nullptr)
		m_mapPathToModule.erase(mapIterator);

	return mapIterator->second;
}

// Helper Functions


////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
} // namespace medusa
////////////////////////////////////////////////////////////////////////////////