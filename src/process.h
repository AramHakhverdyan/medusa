#ifndef PROCESS_H
#define PROCESS_H

////////////////////////////////////////////////////////////////////////////////
//
// Includes
//
#ifndef STACK_H
#	include "stack.h"
#endif

#ifndef CONTEXT_H
#	include "context.h"
#endif

#ifndef EXPRESSION_H
#	include "expression.h"
#endif

#ifndef MODULE_H
#	include "module.h"
#endif

// STD Includes
#include <map>
#include <memory>
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
namespace medusa {
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//
// class CProcess
//
class CProcess
{
public:// Constructors
	inline CProcess(std::shared_ptr<CModule> pModule);
	~CProcess() = default;

public:// Interface Methodes
	void Start();
	inline std::shared_ptr<CStack>& GetStack() const;

private:
	std::shared_ptr<CStack> m_pStack;
	std::shared_ptr<CModule> m_pModule;
	std::shared_ptr<CContext> m_pContext;
	std::unique_ptr<CExpressionManager> m_pExpressionManager;
};
////////////////////////////////////////////////////////////////////////////////

///////////////////////// Implementing inline methods //////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// class CProcess
//

// Constructors
CProcess::CProcess(std::shared_ptr<CModule> pModule)
	: m_pModule(pModule)
{
	m_pStack = std::shared_ptr<CStack>(new CStack(100));
	m_pContext = std::shared_ptr<CContext>(new CContext(m_pStack, m_pModule));
	m_pExpressionManager = std::unique_ptr<CExpressionManager>(new CExpressionManager(m_pModule));
}

// Interface Methodes

////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
} // namespace medusa
////////////////////////////////////////////////////////////////////////////////


#endif // PROCESS_H